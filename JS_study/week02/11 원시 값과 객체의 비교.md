# 11 원시 값과 객체의 비교
## JS가 제공하는 8가지 데이터 타입  

> **원시 타입 (Primitive Type)**   
* `number`, `string`, `boolean`, `null`, `undefined`, `Symbol`, `BigInt`(2020에서 추가)  
* **변경 불가능**한 값 (immutable value)
* 원시 값을 변수에 할당하면 변수(메모리 공간)에는 **실제 값**이 저장된다.
* 원시 값을 갖는 변수를 다른 변수에 할당하면 **원시 값이 복사되어 전달**  - ***값에 의한 전달 (pass by value)***
	
> **객체 타입 (Object/reference Type)**  
* `object` (Array, Function, Date, RegExp 도 사실상 Object의 인스턴스)
* **변경 가능**한 값 (mutable value)
* 객체를 변수에 할당하면 변수(메모리 공간)에는 **참조 값**이 저장된다.
* 객체를 가리키는 변수를 다른 변수에 할당하면 **원본의 참조 값이 복사되어 전달** - ***참조에 의한 전달 (pass by reference)***


## 원시 값
> 원시 타입, 변경 불가능한 값, read only   

```js
var 변수 = '값';

// 1) 변수 : 하나의 값을 저장하기 위한 메모리 공간
// 2) 값 : 변수에 저장된 데이터. 표현식이 평가되어 생성된 결과.
```

### 원시 값의 특성
#### 1. 불변성
1. **"원시 값을 변경은 불가능하다"**는 것은 무슨 뜻인가요?
	* *변수*가 아닌 **원시 값**의 직접적인 변경이 안 된다는 것.

#### 2. 재할당을 통해서 변경한다.
2. 변수에는 언제든 값을 교체할 수 있다 - *재할당* (<-> 상수 : 재할당이 금지된 변수)
	* 재할당을 하면 
		1. 원시 값을 변경하는 것이 아닌 
		2. 새로운 메모리 공간을 확보 후 재할당한 원시 값을 저장 후 변수는 새롭게 **저장된 메모리 공간**을 가르키게 되는 것. (재할당도 참조하던 메모리 공간의 주소가 바뀐다.)

즉, 원시 값은 변경 불가능한 값으로 값을 직접 변경할 수 없다. - *불변성*  
불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다.

#### 3. 문자열과 불변성, 유사 배열 객체
원시 값을 저장하기 위해서는 미리 확보해야하는 메모리 공간의 크기를 결정해야 한다.  
C언어나 Java에서는 문자를 위한 데이터 타입(Char)이 있거나 String 객체로 처리함.  

그러나,
* JS에서는 **문자열 타입**을 제공. 불변성을 갖는 원시 값.
* 유사 배열 객체이고, 이터러블이다.

```
유사 배열 객체?
* 배열처럼 인덱스로 접근이 가능하고, length를 갖음
* 그러나, 접근만 가능하고 변경은 불가능하다.

원시 값을 객체처럼 사용하면 원시 값을 감싸는 *래퍼객체*로 자동 변환됨.
```

#### 4. 값에 의한 전달 혹은 공유에 의한 전달
- **값에 의한 전달**  
원시 값을 갖는 변수를 할당하면, 할당받는 변수에 할당되는 변수의 원시 값이 복사된다.    
그러나, score 변수와 copy 변수의 값 80은 **다른 메모리 공간에 저장된 별개의 값**이다.  
```js
var score = 80;
var copy = score;

console.log(score); // 80
console.log(copy); // 80

score = 100;

console.log(score); // 100
console.log(copy); // 80
```

> 사실 값에 의한 전달도 '값'이 아닌 메모리 주소를 전달하는 것이다. 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있는 것.



## 객체
객체의 프로퍼티의 개수는 정해지지 않았다. 동적으로 추가 삭제 가능하다. 프로퍼티 값에 대한 제약도 없다
=> 따라서, 메모리 공간의 크기를 사전에 정할 수 없다.  

### 객체 타입의 값, 참조 값
#### 1. 변경 가능한 값
객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 참조 값에 접근할 수 있다.  
참조 값은 생성된 객체가 저장된 메모리 공간의 주소 그 자체다.

객체는 변경 가능한 값으로 메모리에 저장된 객체를 직접 수정할 수 있다.  
-> 여러 개의 식별자가 하나의 객체를 공유할 수 있다는 단점이 있다.

##### 얕은 복사 vs 깊은 복사
* 얕은 복사 : 속성 값이 원시 값이면 그대로 가져오고, **참조 값인 경우 참조값을 가져옴.**
	* **참조가 연결되어져 있으므로** 원본 객체의 참조형 속성을 변경하면, 얕은 복사된 새로운 객체에도 **이 변경사항이 반영 됨.**
* 깊은 복사 : **완전히 독립적인 새로운 객체**. 원본 객체가 수정되더라도 깊은 복사된 새로운 객체는 **참조값이 끊겨 있으므로** 영향을 받지 않는다.

###### 객체에서의 얕은 복사와 깊은 복사
객체의 경우 **얕은 복사**와 **깊은 복사**로 생성된 객체는 *원본과는 다른 객체*이다.   
그러나, 
1. 얕은 복사는 **객체에 중첩되어 있는 객체의 경우 참조값을 복사**하고, 
2. 깊은 복사는 **중첩 객체까지 모두 복사**하여 **원시 값 처럼 완전한 복사**를 하는데에 차이가 있다.  
```js
const o = {
	x: {
  	y: 1
  }
};

// 얕은 복사 - 중첩 객체는 참조값이 복사되었다.
const c1 = {...o};
console.log(c1 === o); // false
console.log(c1.x === o.x); // true - 중첩 객체는 참조 값이 복사

// 깊은 복사 - 참조 값을 다 끊어내어 완전히 별개의 값이 됨
// lodash, JSON.stringfy 등등 사용한다.
const _ = require('lodash');
const c2 = _.cloneDeep(o);
console.log(c2 === o); // false
console.log(c2.x === o.x); // false
```

```js
// "원시 값 복사"를 "깊은 복사"라고도 부른다. (별개의 값이므로)
const v = 1;
const c1 = v; 

// "객체 값 복사"를 "얕은 복사"라고도 부른다. (참조 값이 끊기지 않고 같은 객체를 바라보므로...)
const o = { x : 1 };
const c2 = o; 
console.log(o === c2); // true
```

#### 2. 참조에 의한 전달
여러 개의 식별자가 하나의 객체를 공유한다.  
참조 값을 복사하기 때문이다.

