# 10 객체 리터럴
1. **원시 값**
	* 단 하나의 값만 나타낸다.
	* 변경 불가능한 값 (= `immutable value`)
2. **객체 타입**
	* 다양한 타입의 값을 하나의 단위로 구성한 복잡적인 자료 구조
	* 변경 가능한 값 (= `mutable value`)

## 10.1 객체란?
* JS는 객체 기반 프로그래밍 언어이다.
* JS를 구성하는 거의 **"모든 것**"이 객체다.
	* (*원시 값을 제외한 나머지 값 - 함수, 배열, 정규 표현식*)
* 0개 이상의 프로퍼티로 구성된 집합으로 프로퍼티는 키(`key`)와 값(`value`)로 구성된다.
* JS 함수는 **일급 객체**여서 **값으로 취급 가능**하다. (프로퍼티가 함수일 경우 `method`라 부른다.)


## 10.2 객체 리터럴에 의한 객체 생성
`new` 키워드를 사용하여 인스턴스를 생성하는 방식으로 객체를 생성한다.
* 인스턴스: 클래스에 의해 생성되어 메모리에 저장된 실체


객체를 생성하는 방법은 여러가지가 있다.
* 객체 리터럴
* Object 생성자 함수
* 생성자 함수
* Object.create 메서드
* 클래스(ES6)

```js
// 객체 리터럴
var person = {
  name: 'lee',
  sayHello() {
    console.log(`hi~ ${this.name}`)
  }
}

console.log(typeof person); //object
console.log(person); // {name: 'lee', sayHello: f}
```

- [!] 주의할 점은 객체 리터럴의 중괄호는 코드 블록이 아니다! 값으로 평가되는 표현식이다.
- [!] 리터럴로 생성할 시, 클래스 정의, new 키워드를 통한 생성자 호출 과정이 필요 없다.

## 10.3 프로퍼티
객체는 프로퍼티의 집합이며, 프로퍼티는 키와 값으로 구성된다.
* 프로퍼티 키 `key` : 빈 문자열을 포함하는 모든 문자열 또는 심벌 값, 값에 접근하기 위한 식별자 역할
* 프로퍼티 값 `value` : 자바스크립트에서 사용할 수 있는 모든 값

### 프로퍼티 키 특성
1. 식별자 네이밍 규칙이 있다. 
	1. 문자열이어야 한다.
	2. 식별자 네이밍 규칙을 준수한다면, 따옴표 생략도 가능하다. 
	3. 반대의 경우 무조건 따옴표를 넣어야 한다.
2. 키 동적 생성
	1. [] 대괄호를 사용한다
3. 키 값으로 문자열이나 심벌 값 외의 값을 사용하면 '암묵적 타입 변환'을 통해 문자열이 된다.
4. 예약어는 사용하지 않는다. ex) `var`,  `function`
5. 중복 선언 시 나중에 선언한 프로퍼티가 덮어쓴다. 

### 프로퍼티 키 특성 예시

1. 식별자 네이밍 규칙
```js
var person = {
  firstName: 'Ung-mo', // 식별자 네이밍 규칙 준수 한 프로퍼티 키
  'last-name': 'lee' // 식별자 네이밍 규칙 준수하지 않은 프로퍼티 키
}

원래 식별자는 따옴표를 생략할 수 있으나, 'last-name'의 경우 - 연산자가 있는 표현식으로 해석하므로,
가급적 식별자 네이밍 규칙을 따르는 것을 권장한다.
```

2. 키 동적 생성
```js
var obj = {};
var key = 'hello';

obj[key] = 'world';

console.log(obj); // {hello: "world"}

문자열 또는 문자열로 평가할 수 있는 표현식을 사용하여 프로퍼티 키를 동적으로 생성한다.  
이때, 프로퍼티 키는 [] 대괄호로 묶어주면 된다.
```

```js
var foo = {
  '': '' // 에러는 없다. 그러나 의미도 없다.
}
빈 문자열도 프로퍼티 키로 이용가능하다.
그러나, 키로써의 의미를 갖지 못 한다.
```

## 10.4 메서드
JS 함수는 **"일급 객체"** 이고 값으로 취급된다.  
모든 값은 프로퍼티 값으로 사용할 수 있다.

> 메서드에 대한 명확한 정의  
* **ES6 이전**   
	: 일반적으로 메서드는 객체에 바인딩된 함수를 일컬었다.
* **ES6 이후**   
	: ES6 사양에서의 **메서드**는 **메서드 축약 표현으로 정의된 함수**만을 의미한다.

```js
const obj = {
	x: 1,
	// foo는 메서드
	foo() {
		console.log('메서드 축약 표현으로 정의된 메서드입니다.')
	},
	// bar는 일반 함수입니다.
	bar: function() {
		console.log('저는 그냥 일반 함수예요...')
	}
}
```

> `non-constructor` 
* 인스턴스 생성할 수 없다.
* 즉, prototype 프로퍼티도 없고, 생성도 안 한다.

## 10.5 프로퍼티 접근
접근 방식 두 가지
1. `.` 마침표 프로퍼티 접근 연산자 사용: **마침표 표기법**
2. `[]` 대괄호 프로퍼티 접근 연산자 사용: **대괄호 표기법**
	1. 주의) 대괄호 안에 들어갈 키가 따옴표로 감싼 문자열이어야 한다.
	2. 그렇지 않을 경우 식별자로 해석함.
```js
var person = {
  name: 'lee'
}
console.log(person[name]); // ReferenceError: name is not defined
console.log(person['name']); // lee 대괄호 표기법 - (O)
```

## 10.6~8 프로퍼티 값 갱신 / 동적 생성 / 삭제
```js
var person = {
  name: 'lee'
}

// 이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값이 갱신된다.
person.name = 'Kim';
console.log(person); // {name: 'Kim'}

// 존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당된다.
person.age = 20;
console.log(person); // {name: 'Kim', age: 20}

// delete 연산자로 객체의 프로퍼티를 삭제한다.
delete person.age; // age 삭제
delete person.address; // 없는 값을 삭제해도 에러 없다.
```

## 10.9 ES6에서 추가된 객체 리터럴의 확장 기능
1. 프로퍼티 축약 가능
```js
var x = 1, y = 2;
var obj = { x, y }
```
2. 계산된 프로퍼티 이름 = Computed property name
```js
const prefix = 'prop';
let i = 0;

const obj = {
	[`${prefix}-${++i}`]: i,
	[`${prefix}-${++i}`]: i,
	[`${prefix}-${++i}`]: i
}

console.log(obj); // {prop-1: 1, prop-2: 2, prop-3: 3}
```
3. 메서드 축약 표현
```js
// ES5
var obj = {
  name: 'Lee',
  sayHi: function() {
    console.log('hi~')
  }
}

// ES6
const obj = {
  name: 'Lee',
  // 축약 표현 - 프로퍼티에 할당한 함수와 약간 다르게 동작한다. (non-constructor)
  sayHi() {
    console.log('hi~')
  }
}

```




---
