# 12 함수
JS에서 함수는 가장 중요한 핵심 개념이다.  
스코프, 실행 컨텍스트, 클로저, 생성자 함수에 의한 객체 생성, 메서드, this, 프로토타입 모듈화 등 함수와 관련이 있다.
## 함수
### 함수란?   
인풋을 받아 일련의 과정을 통해서 아웃풋을 내보냄.  
일련의 과정을 문으로 구현하여 코드 블록으로 감싸서 하나의 실행단위로 정의  

* 매개 변수(parameter) : 함수 내부로 입력을 전달받는 변수
* 인수(argument) : 입력 값
* return 값 : 출력 값

```js
// 함수 정의
function add(x, y) {
	return x + y;
}

// 함수 호출
add(2, 5);
```

### 함수 사용하는 이유
* 코드의 재사용
	1. 유지보수의 편의성 높임
	2. 코드의 신뢰성 높임
	3. 코드의 가독성 향상
	
### 함수 리터럴의 구성
1. 함수 이름
	1. 식별자이다. 네이밍 규칙이 있다.
	2. 함수 이름은 함수 몸체 내에서만 참조할 수 있다.
	3. 이름이 있다면 기명함수, 이름이 없다면 무명/익명 함수
2. 매개변수 목록
	1. 0 개 이상의 매개변수를 소괄호로 감싸고, 쉼표로 구분한다.
	2. 매개변수 목록은 순서에 의미가 있다.
3. 함수 몸체
	1. 함수가 호출되었을 때 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한다.

함수는 호출할 수 있는 객체다.

## 함수 정의
호출하기 전에 인수를 전달받을 매개변수와 실행할 문들, 반환 값을 지정하는 것이다.  
정의된 함수는 JS 엔진에 의해 평가되어 함수 객체가 된다.

> 함수 정의 방법 4가지
> * 함수 선언문, 함수 표현식, Function 생성자 함수, Arrow function (ES6) 	

### **1. 함수 선언문**  
실행 완료 값으로 `undefined`가 출력됨.  
```js
function add(x, y) {
	return x + y;
}

// undefined
```
함수 리터럴과 동일하나, 함수 리터럴은 이름 생략이 가능한 대신  
함수 선언문은 이름을 생략할 수 없다.  

### **2. 함수 표현식**
변수에 함수 리터럴로 생성한 함수 객체를 할당하여 사용한다.  
일급 객체이기 때문에 값으로써 사용할 수 있다.  
```js
// 함수 리터럴, 익명함수
var add = function (x, y) {
	return x + y;
}
add(1, 5);

// 기명함수
var mul = function multiple(x, y) {
	return x * y;
}
mul(2, 3); // 6
// 함수 이름은 함수 몸체 내부에서만 유효한 식별자이다.
multiple(2, 3); // ReferenceError: multiple is not defined
``` 

### **3. 함수 생성 시점과 함수 호이스팅**

사실 함수 호이스팅이 아닌 변수 호이스팅일 뿐이다.

```js
// 함수 참조
console.dir(add); // f add(x, y)
console.dir(sub); // undefined

// 함수 호출
console.log(add(2, 5)); // 7
console.log(sub(2, 5)); // TypeError: sub is not a function (얘는 아직 함수인지 모르니까)

// 함수 선언문
function add(x, y) { // 함수 호이스팅
	return x + y;
}

// 함수 표현식
var sub = function (x, y) { // 여기 할당문에서 평가되어 함수 객체가 된다.
	return x - y;
}
```
위의 예제를 설명해 본다.  
함수 선언문은 선언문 이전에 호출할 수 있다. 
또 함수 표현식의 경우, 표현식 이전에 호출할 수 없다.

이는 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르기 때문이다. 

모든 선언문이 그러하듯 런타임 이전에 자바스크립트 엔전에 의해 먼저 실행된다.  
그래서 함수 선언문으로 정의하면 런타임 이전에 함수 객체가 먼저 생성된다.  

함수 표현식으로 정의할 경우, 변수에는 `undefined`로 초기화가 되고, 선언문을 만나야만 함수 객체로 초기화가 된다.

### **4. Function 생성자 함수**
```js
var add = new Function('x', 'y', 'return x + y');
```

누가 이렇게 쓸까? ㅋㅋ
new 키워드 사용하면 클로저 생성도 안하고, 함수 선언문이나 함수 표현식으로 생성한 함수와도 다르게 동작한다. 

### **5. Arrow function (ES6)**
ES6에서 도입된 화살표 함수이다.  
항상 익명 함수로 정의한다.  
```js
var add = (x, y) => x + y;
```

* 화살표 함수는 생성자 함수로 사용할 수 없다.
* 기존 함수와 this 바인딩이 다르다.
* prototype 프로퍼티가 없고 arguments 객체를 생성하지 않는다. 

## 함수 호출
### 1. 매개변수와 인수
함수를 실행하기 위해서, 매개변수(인자=parameter)를 통해서 인수(argument)를 전달한다.

```js
// 함수 선언문
function add(x, y) {
	return x + y;
}

// 함수 호출
var result = add(1, 2);
```
매개변수도 undefined로 초기화된다.

### 2. 인수 확인
1. 자바스크립트 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않는다.
2. 자바스크립트는 동적 타입 언어로 사전에 타입을 지정할 수 없다.
	1. 타입스크립트와 같은 정적 타입을 선언하는 방법으로 해결할 수 있다.

```js
// 적절한 인수가 전달되었는가?
function add(x, y) {
	if (typeof x !== 'number' || typeof y !== 'number') {
		throw new TypeError('인수는 모두 숫자여야 합니다.')
	}
	return x + y;
}

console.log(add(2)); // TypeError: 인수는 모두 숫자여야 합니다.
console.log(add('a', 'b')); // TypeError: 인수는 모두 숫자여야 합니다.
```

```js
// 단축 평가로 매개변수에 기본 값 할당
function add(a, b, c) {
	a = a || 0;
	b = b || 0;
	c = c || 0;
	return a + b + c;
}
```

```js
// ES6에 도입된 기본값 설정
function add(a = 0, b = 0, c = 0) {
	return a + b + c;
}
```

### 3. 매개변수의 최대 개수
이상적인 함수 = 한 가지 일만 해야 하며 가급적 작게 만든다.
- 3개 이상 넘지 않는 것을 권장

### 4. 반환문
return 키워드는 표현식의 평가 결과를 반환한다.

## 참조에 의한 전달과 외부 상태의 변경
매개변수도 함수 몸체 내부에서 변수와 동일하게 취급되므로, 매개변수 또한 타입에 따라 값에 의한 전달, 참조에 의한 전달 방식을 따른다.  

객체의 변경을 추적하기 위해
* 옵저버 패턴 사용
혹은
* 불변 객체로 만들어서 사용

## 다양한 함수의 형태
### 1. 즉시 실행 함수
```js
// 익명 즉시 실행 함수 - 단 한 번만 호출
(function() {
	var a = 3;
	var b = 5;
	return a + b;
}())

// 기명 즉시 실행 함수 - foo는 함수 몸체에서만 참조할 수 있는 식별자다
(function foo(){
	var a = 3;
	var b = 5;
	return a + b;
}());
foo(); // ReferenceError: foo is not defined

(function() {
	// ...
})();

!function () {
	// ...
}();

+function () {
	// ...
}();
```

즉시 실행 함수도 일반 함수처럼 값을 반환하거나, 인자를 전달할 수 있다.
```js
// 즉시 실행함수도 일반 함수처럼 값을 반환.
var res = (function() {
	var a = 3;
	var b = 5;
	return a + b;
}());
console.log(res) // 8

// 즉시 실행 함수도 일반 함수처럼 인수를 전달.
res = (function(a, b) {
	return a + b;
}(3, 5));
console.log(res); // 8
```

### 2. 재귀 함수 (recursive call)
자기 자신을 계속해서 호출하는 함수
```js
// 팩토리얼 함수
function fac(n) {
	if (n <= 1) return 1;
	return n * fac(n - 1);
}

혹은 함수 표현식으로 재귀함수
var fac = function foo(n) {
	if (n <= 1) return 1;
	return n * fac(n - 1);
}
```
함수 이름은 함수 몸체 내부에서만 유효하다.  
식별자를 활용하여 재귀함수를 구현했다.

재귀 함수는 for나 while로도 가능하다
```js
function fac(n) {
	if (n <= 1) return 1;
	var res = n;
	while (--n) res *= n;
	return res;
}
```

### 3. 중첩 함수
함수 내부에 정의된 함수를 중첩 함수 또는 내부 함수 라고 부른다.
이를 포함하는 함수를 외부 함수 라고 부른다.

중첩 함수는 
* 외부 함수 내부에서만 호출할 수 있다.
* 주로 자신을 포함하는 외부 함수를 돕는 헬퍼 함수의 역할을 한다.

```js
function outer() {
	var x = 1;
	function inner() {
		var y = 2;
		console.log(x + y); // 3
	}
	inner();
}
outer();
```

중첩 함수는 클로저와도 깊은 관련이 있다. 

### 4. 콜백 함수
#### 콜백함수
함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백 함수라고 한다.

#### 고차함수
매개 변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 고차 함수라고 한다.

* 다른 함수를 인자로 받거나, 결과로 반한한다.  
* 고차 함수는 콜백 함수를 자신의 일부분으로 합성한다.

고차 함수는 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정해서 호출한다.  
콜백 함수는 고차 함수에 의해 호출되며, 이때 고차 함수는 필요에 따라 콜백 함수에 인수를 전달한다.  

#### 콜백 함수 패턴의 사용처
비동기 처리(이벤트 처리, ajax 통신, 타이머 함수)

### 5. 순수 함수와 비순수 함수

* 순수 함수 : 어떤 외부 상태에 의존하지 않고 변경하지도 않는, 즉 부수효과가 없는 함수.
	* 동일한 인수가 전달되면 언제나 동일한 값을 반환한다.
* 비순수 함수 : 순수 함수의 반대

함수 내부에서 외부 상태를 직접 참조하게 되면 외부 상태에 의존하게 되서 반환값이 변할 수 있다. 
그렇기 때문에 이는 비순수 함수가 되면서 추적이 어려워진다는 단점이 있다.

