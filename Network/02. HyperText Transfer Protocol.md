* 처음엔 HyperText만 전송

그러나,  

## 모든 것이 HTTP
HTTP 메시지에 모든 것을 전송한다.
* HTML, TEXT
* Image, 음성, 영상, 파일
* JSON, XML
* 거의 모든 형태의 데이터 전송이 가능
* 서버간에 데이터를 주고 받을 때도 대부분 HTTP 사용

## 역사
**HTTP/1.1 : 대부분의 기능이 다 들어있음. 가장 많이 사용 됨.**  
HTTP/2 : 성능 개선된 것
HTTP/3 : TCP 대신에 UDP 사용, 성능 개선된 것

## 기반 프로토콜
TCP: HTTP/1.1, HTTP/2
UDP: HTTP/3

> TCP는 3-way 핸드쉐이킹도 해야하고 데이터도 많기 때문에 매커니즘이 속도가 빠르지 못하다.


## HTTP 특징
1. 클라이언트-서버 구조
2. stateless, 비연결성
3. HTTP 메시지
4. 단순함, 확장 가능

### 1. 클라이언트-서버 구조
* reqeust response 구조
* 클라이언트는 서버에게 요청을 보내고 응답을 대기한다
* 서버가 요청에 대한 결과를 만들어서 응답한다.

#### 왜 이런식으로 구조를 나누었나? 
오래 전에는 서버와 클라가 분리되어져 있지 않았음
=> 이후 클라이언트와 서버가 개념적으로 분리됨  

* 클라이언트는 UI 사용성에 집중.  
* 서버는 비지니스 로직, 데이터를 담당.   

서로 독립적인 진화가 가능하다.  


### 2. 무상태 stateless  
* 서버가 클라이언트의 상태를 보존하지 않는다.

#### stateful vs. stateless
> stateful - 상태 유지
문맥을 유지한다.  
```
* 고객: 이거 노트북 얼마야?
* 점원: 100만원. **(노트북 상태 유지)**

* 고객: 2개 구매할게
* 점원: 200만원이야. 신용카드, 현금 중 어떤 걸로 구매할래? **(노트북, 2개 상태 유지)**

* 고객: 신용카드
* 점원: 200만원 결제 완료.  **(노트북, 2개, 신용카드 상태 유지)**
```

만약, 점원이 중간에 바뀐다면??
```
* 고객: 이거 노트북 얼마야?
* 점원A: 100만원.

* 고객: 2개 구매할게
* 점원B: ? 무엇을 2개 구매한다고?

* 고객: 신용카드
* 점원C: ? 무슨 제품을 몇 개 신용카드로 구매하겠다고?
```
문제가 생김..


> stateless - 무상태

```
* 고객: 이거 노트북 얼마야?
* 점원A: 100만원.

* 고객: 노트북 2개 구매할게
* 점원B: 노트북 2개는 200만원이야. 신용카드, 현금 중 어떤 걸로 구매할래?

* 고객: 노트북 2개를 신용카드 구매할게
* 점원C: 200만원 결제 완료. 
```

무상태의 경우 중간에 서버가 장애가 나더라도, 상태를 보관하지 않기 때문에 크게 문제가 없다. (요청에 담아서 보내기 때문)

문제는 상태를 유지(로그인) 해야하는 경우에는 브라우저 쿠키와 서버 세션을 사용한다.  

### 3. 비연결성 connectionless
* HTTP는 기본적으로 연결을 유지하지 않는 모델이다.
* 일반적으로 초 단위 이하의 빠른 속도로 응답한다.
* 1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 작다.  
	* 웹 브라우저에서 계속 연속해서 검색 버튼을 누르지 않으니..
* 서버 자원을 매우 효율적으로 사용할 수 있다.

### 3-1. 비연결성의 한계와 극복
**문제**  
* 웹 브라우저를 요청하면, html 뿐만 아니라 js, css, image, 영상 등 수많은 리소스들이 다운로드 된다.   
* 중간에 검색을 하거나 다음 페이지로 넘어가게 된다면  
=> TCP/IP 연결을 새로 맺어야 함 - 3 way handshake 시간 추가된다. (오버헤드 발생)  

**해결**  
* http `지속 연결(persistent connection)`로 문제를 해결한다.
* http/2, http/3에서 조금 개선이 되었다.  


클라와 서버간의 연결을 계속 유지하면 서버 자원이 소모되므로 비연결성을 사용한다.  
그러나 매 요청마다 TCP/IP의 handshake를 수행하기에 오버헤드가 생긴다.   
이를 persistent connection을 사용하여 일시적으로 연결을 유지시키고, 일정 시간 동안 통신이 없다면 연결을 끊어 비연결성을 유지시킨다.  


### HTTP 지속 연결 (Persistent Connections)
**초기**
```
클라 <-> 서버 

* 연결
* 요칭/HTML응답
* 종료

* 연결
* 요칭/JS응답
* 종료


* 연결
* 요칭/이미지 응답
* 종료
```

약 0.9초가 걸렸다.

**HTTP 지속 연결**
```
클라 <-> 서버

* 연결
* 요청/HTML응답
* 요칭/JS응답
* 요칭/이미지 응답
* 종료
```

약 0.5초 걸림!

심지어 http/3는 연결 속도조차 줄였다고 한다.

---
### HTTP 메시지
1. status code
	1. 200: 성공
	2. 400: 클라이언트 요청 오류
	3. 500: 서버 내부 오류


### HTTP 메서드
#### HTTP API 설계
1. 가장 중요한 것은 **리소스 식별**이다.  
2. URI 계층 구조를 활용한다.  

* 리소스?
	* 명사
* 어떻게 리소스 식별?
	* 회원 등록, 수정, 조회하는 것을 모두 배제한다.
	* 회원이라는 리소스만 식별하면 된다. -> 이를 URI에 매핑
* 리소스(명사)와 행위(동사) 분리
	* URI는 리소스만 식별
	* 리소스와 해당 리소스를 대상으로 하는 행위를 분리
		* 리소스: 회원
		* 행위: 조회, 등록, 수정, 삭제
* 행위(메서드)는 어떻게 구분?
	* HTTP 메서드가 이를 대신해준다.  

[요구사항]  
- 회원정보관리 API  

**API URI 설계**
	- **회원** 목록 조회 `/members`
	- **회원** 조회 `/members/{id}` - 어떻게 구분해?
	- **회원** 등록 `/members/{id}` - 어떻게 구분해?
	- **회원** 수정 `/members/{id}` - 어떻게 구분해?
	- **회원** 삭제 `/members/{id}` - 어떻게 구분해?

#### HTTP 메서드 - GET, POST
1. GET
	1. 리소스 조회
2. POST
	1. 요청 데이터 처리, 등록에 사용
3. PUT
	1. 리소스 _대체_, 해당 리소스가 **없으면 생성**
4. PATCH
	1. 리소스 _부분_ 변경
5. DELETE
	1. 리소스 삭제
6. HEAD, OPTIONS, CONNET, TRACE

